## HTTP的1.0\2.0\3.0区别

### http1.0
 1. 1.0的http版本，是一种无状态，无连接的应用层协议。规定浏览器和服务器保持短暂的链接。
 2. 浏览器每次请求都需要与服务器建立一个TCP链接。服务器处理完成以后立即断开TCP链接（无连接），不会记录用户得cookie和以前的请求。

弊端
 1. 无法复用链接，因为每次请求都需要进行一次TCP链接，而TCP链接释放过程又是比较费事的，这种无链接的特性会使用网络利用率变低；
 2. 队头阻塞，由于http 1.0规定下一个请求必须在前一个请求响应到达之前才发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就会阻塞。

### http1.1
 1. http1.1继承了http1.0的简单，克服了HTTP1.0性能上的问题
 2. 长链接。HTTP1.1增加connection字段，通过设置keep-alive保持HTTP链接不断卡，避免每次客户端与服务器请求都要重复建立和释放TCP链接，提高了网络的利用率。

### http2.0（SPDY的升级版）

 * HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。
 * 和HTTP 1.x使用的header压缩方法不同。
 * HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。
 * 多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。

**HTTP2.0的多路复用提升了网页性能**
 * 在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。
 * HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。


### http3.0
QUIC (Quick UDP Internet Connections), 快速 UDP 互联网连接。由Google在 2015年提出的SPDY v3演化而来的新协议。
QUIC是基于UDP协议的。

 * 基于google的QUIC协议，而quic协议是使用udp实现的
 * 减少了tcp三次握手时间，以及tls握手时间
 * 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题
 * 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
 * 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
 * 更合适的流量控制

---

## HTTPS和HTTP
**客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤**
 1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
 2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
 3. 客户端拿到CA证书之后，会将证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。
 4. 如果一致，则客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
 5. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
 6. Web服务器利用自己的私钥解密出会话密钥。
 7. Web服务器利用会话密钥加密与客户端之间的通信。

### 中间人攻击
服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把中间人自己的公钥冒充服务器的公钥传输给了客户端。

之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又把密钥给截取了，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。

最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。毫无疑问，在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别

### CA证书
CA证书包含了：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。

我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫数字签名

[CA证书参考](https://www.cnblogs.com/xulan0922/p/14778644.html)

---

## TCP三次握手
 * 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认
 * 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态
 * 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手
 
 ![tcp三次握手](/assets/data_structure/tcp_link.png)